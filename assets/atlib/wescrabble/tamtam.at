/*
 * TamTam is a shared tuplespace module with the following features:
 * - Shared across devices, acceptance rule for shared tuples.
 * - Tuplespace operations: out=put, in=take, peek=getAll
 * - The emitter of a tuple always has authority on his deletion (like totam)
 * 
 * TODO:
 * - mark peers as disconnected, their tuples are temporarily not accessible
 * - Detects failures with timeouts
 */

def List := jlobby.java.util.LinkedList;
def Dict := jlobby.java.util.HashMap;

import ~.utils;
import ~.tuple;
deftype TupleSpace;

/* Timeout for remote calls.
* A peer is considered offline if it overrun this timeout.
* Might be enhanced with dynamic evaluation ? */
def DISCONNECT_TIMEOUT := 10.seconds;

def remove: tup from: aList {
    def i := 0;
    def removeMeth := aList.&remove; // Grab remove(idx) method
    def it := aList.iterator();
    {|return|
        while: {it.hasNext()} do: {
            def x := it.next();
            if: tup.match(x)
            then: {
                removeMeth.cast(jlobby.java.lang.Integer.TYPE)(i);
                return(true);
            };
            i := i+1;
        };
        return(false);
    }.escape();
};

/* Return an ambient tuple space endpoint
 * @param typetag: The typetag exported by the ambient tuplespace
 *                 (no collisions for tests)
 */
def TamTam(typetag := TupleSpace, accept := always: true){
    def log := Logger("TamTam", true);
    
    def peers := List.new;     // [remoteRef]: All discovered peers
    def ambientDb := Dict.new; // {remoteRef: [tuple]}: All tuples sent by peers
    def online := Dict.new;    // {remoteRef: true/false}: is the player online
    def localDb := List.new;   // [tuple]: Local tuples
    def takeWait := [];        // waiting take() call 
    def observers := [];       // Registered observe calls

    def isOnline(peer){
        def x := online.get(peer);
        (x != nil).and: {x};
    };

    /* Like when:becomes: but mark peer as disconnected on timeout.
     * Note that closure might be not executed
     *  (if the peer is not online at the moment) */
    def when: msg from: peer becomes: closure {
        when: due(DISCONNECT_TIMEOUT, peer <+ msg)
        becomes: closure
        catch: DueTimeout using: {|exc|
            online.put(peer, false);
            log(peer, "now considered offline")
        };
    };

    /* Iterate on local tuples */
    def eachLocal: closure {
        def it := localDb.iterator();
        while: { it.hasNext() } do: {closure(it.next())};
    };

    /* Iterate on ambient tuples */
    def eachAmbient: closure {
        def peerIt := ambientDb.keySet().iterator();
        while: { peerIt.hasNext() } do: {
            def peer := peerIt.next();

            if: isOnline(peer)
            then: {
                def it := ambientDb.get(peer).iterator();
                while: { it.hasNext() } do: {closure(peer, it.next())};
            };
        }
    };

    /* Iterate on all tuples */
    def each: closure {
        eachLocal: closure;
        eachAmbient: {|peer, tup| closure(tup)};
    };

    /* Remove a local tuple an propagate deletion to other spaces */
    def removeLocal(tup){
        def it := peers.iterator();
        while: { it.hasNext() } do: {
            it.next()<-removeCopy(self, tup)@OneWay;
        };
        remove: tup from: localDb;
    };

    /* Internal method to take tuples from the tuplespace.
     * TamTam attemps to take ambient tuples first.
     */
    def take: aTuple withResolver: res {
        /* Find peers who might have the tuple */
        def remoteCandidates := [];
        eachAmbient: {|peer,tup|
            if: aTuple.match(tup)
            then: {remoteCandidates := remoteCandidates + [[peer, tup]]};
        };

        /* Try to remove local tuple.
         * If no local tuple has been taken, try to take an ambient tuple.
         * If no ambient tuple matches, enqueue the take() and reprocess when
         * new tuples arrive.
         */
        {|return|
            /* Local remove */
            eachLocal: {|tup|
                if: aTuple.match(tup)
                then: {
                    res.resolve(tup);
                    return(removeLocal(tup));
                }
            };

            removeAmbient(
                {|tup| res.resolve(tup)},
                {|@_| /* Enqueue pending take() */
                      takeWait := takeWait + [[aTuple, res]]},
                @remoteCandidates
            );
        }.escape();
    };

    /* Attempt to process pending take() call */
    def tupleArrived(tup){
        log("New tuple arrived: " + tup.fields);

        observers.each: {|x|
            def [pattern, callback] := x;
            if: pattern.match(tup)
            then: {callback(tup)}
        };

        def queue := takeWait;
        takeWait := [];
        queue.each: {|x|
            def [tup, res] := x;
            take: tup withResolver: res;
        };
    };

    def remoteIf := object: {
        /* Another space advertises one of his tuples */
        def advertise(owner, tup){
            /* Peer is back online, send my whole database */
            if: isOnline(owner).not
            then: {
                log(owner, "is back online");
                owner<-advertiseAll(self, @(localDb.toArray))@OneWay
            };

            online.put(owner, true);
            if: accept(tup)
            then: {
                def known := ambientDb.get(owner);
                if: known == nil then: {
                    known := List.new;
                    ambientDb.put(owner, known);
                };
                known.add(tup);
                tupleArrived(tup);
            }
        };

        /* Another space advertises its whole database */
        def advertiseAll(owner, @tups){
            online.put(owner, true);
            def res := List.new;
            tups.each: {|t|
                if: accept(t)
                then: {
                    res.add(t);
                    tupleArrived(t);
                };
            };
            ambientDb.put(owner, res);
        };

        /* Another space notify that it has deleted one of his tuples */
        def removeCopy(owner, tup){
            log("Remove shared tuple", tup.fields);
            if: accept(tup)
            then: {
                def db := ambientDb.get(owner);
                if: db != nil
                then: {remove: tup from: db};
            };
        };

        /* Another space wants to remove a tuple owned by me */
        def remove(tup){
            log("Give local tuple", tup);
            removeLocal(tup);
        };

        /* Go online ! */
        export: self as: typetag;
        whenever: typetag discovered: {|other|
            log("Discovered", other);

            /* Save ref to other peer for later use */
            peers.add(other);
            online.put(other, true);
            when: other disconnected: {online.put(other, false)};
            when: other reconnected: {
                online.put(other, true);
                //other<-advertiseAll(self, @(localDb.toArray))@OneWay;
            };
            other<-advertiseAll(self, @(localDb.toArray))@OneWay;
        };
    };

    /* Share a tuple to all connected tuplespaces */
    def share(tup){
        def it := peers.iterator();
        while: { it.hasNext() } do: {
            def peer := it.next();
            when: <-advertise(remoteIf, tup)@TwoWay
            from: peer becomes: {|@_|};
        };
    };

    def removeAmbient(contSuccess, contFail, @pairs){
        if: pairs.length == 0
        then: {contFail()}
        else: {
            def [X, @rest] := pairs;
            def [peer, tup] := X;
            when: <-remove(tup)@TwoWay
            from: peer
            becomes: {|removed|
                removed.ifTrue: {
                    contSuccess(tup);
                } ifFalse: {
                    log("Removal failed");
                    removeAmbient(contSuccess, contFail, @rest);
                };
            };
            remove: tup from: ambientDb.get(peer);
        }
    };

    /* Public interface */
    object: {
        /* Put a tuple in the tuplespace */
        def put(tup){
            localDb.add(tup);
            share(tup);
            tupleArrived(tup);
        };

        /* Return all tuples in the tuplespace.
         * If pattern is not nil, filter only matching tuples
         */
        def getAll(pattern := nil){
            def res := List.new;
            each: {|tup|
                if: ((pattern == nil).or: {pattern.match(tup)})
                then: {res.add(tup)};
            };
            res.toArray;
        };

        /* Return a matching tuple from the tuplespace and remove it.
         * @note: Returns a future tuple
         */
        def take(aTuple){
            def [fut, res] := makeFuture();
            take: aTuple withResolver: res;
            fut;
        };

        /* Like take() but invoke a callback instead of returning a future */
        def take: aTuple do: closure {
            when: take(aTuple) becomes: closure;
        };

        /* Invoke a callback everytime a matching tuple is inserted
         * (locally or in the ambient)
         */
        def observe: aTuple do: closure {
            observers := observers + [[aTuple, closure]];
        };

        def observeAll: aTuple do: closure {
            getAll(aTuple).each: {|tup|
                closure(tup);
            };
            observe: aTuple do: closure;
        };

        /* Set the accepting rule for incoming ambient tuples */
        def accepts: acceptor {
            accept := acceptor;
        };
    };
};

self;
