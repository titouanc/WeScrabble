import /.at.lang.futures;
import ~.ambientref;
import ~.suggestion;

/* Direct communication */
deftype AnAwesomeWeScrabble;

def alphabet := "abcdefghijklmnopqrstubwxyz".explode();

def makeWeScrabble(UI){
    UI.setAppTitle("We Scrabble /o/");

    def rand := jlobby.java.util.Random.new();

    object: {
        /* Ambient types */
        deftype Everybody;
        deftype TeamA;
        deftype TeamB;

        def randomID := rand.nextInt();
        def discovered := false;
        def team := nil;
        def observers := jlobby.java.util.LinkedList.new();
        def peers := jlobby.java.util.HashMap.new();
        def table := (1**16).map: {|row|
            (1**16).map: {|column| Suggestion.EMPTY}
        };
        def myLetters := [];

        def takeLetter(letter){
            def found := false;
            myLetters := myLetters.filter: {|l|
                if: (found.not.and: {l == letter})
                then: {
                    found := true;
                    false;
                }
                else: {
                    true;
                }
            };
            found;
        };

        def setDiscovered(){
            discovered := true;
        };

        def notifyObservers(){
            def it := observers.iterator();
            while: { it.hasNext() } do: {
                it.next().update();
            };
        };

        /* Refill myLetters with random letters */
        def refill(){
            def r := 7 - myLetters.length;
            def newLetters := (0**r).map: {|_|
                def i := 1 + rand.nextInt().abs()%26;
                alphabet[i];
            };
            myLetters := myLetters + newLetters;
        };

        /* Apply a suggestion on my state then notify observers */
        def applySuggestion(sugg){
            sugg.applyOn(table);
            notifyObservers();
        };

        def play(sugg){
            def required := sugg.requiredLetters(table);
            required.each: {|l| takeLetter(l)};
            applySuggestion(sugg);
            everybody<-addWord(sugg);
        };

        def localInterface := /.wescrabble.localif.makeLocalInterface(self, UI);

        def remoteInterface := /.wescrabble.remoteif.makeRemoteInterface(self, UI);
        def everybody := ambient: remoteInterface as: Everybody;

        def assignTeamWith: other {
            /* Are team already formed ? */
            def teamsFormed := other<-hasTeam()@TwoWay;

            teamsFormed<-ifTrue: {
                /* Teams already formed: ask someone for a team to join */
                when: other<-getNewcomerTeam()@TwoWay becomes: { |teamTag|
                    team := ambient: remoteInterface as: teamTag;
                };
            } ifFalse: {
                /* Teams not formed: assign teams based on random id */
                when: other<-getRandomID()@TwoWay becomes: {|otherID|
                    while: {(otherID == randomID).and: {discovered.not}}
                    do: {randomID = randInt;};

                    if: (randomID < otherID)
                    then: {
                        team := ambient: remoteInterface as: TeamA;
                        UI.setTeam(0);
                    }
                    else: {
                        team := ambient: remoteInterface as: TeamB;
                        UI.setTeam(1);
                    };

                    UI.showMessage("In game !");
                };
            };
        };

        def discoverPeer(other){
            when: other<-getName()@TwoWay becomes: {|name|
                peers.put(name, other);
                UI.showMessage("Discovered " + name + " !");
                (team == nil).ifTrue: {assignTeamWith: other};
            };
        };

        refill();
        UI.showMessage("Hello " + UI.getMyName() + " ! Waiting for other players...");

        export: remoteInterface as: AnAwesomeWeScrabble;
        whenever: AnAwesomeWeScrabble discovered: &discoverPeer;
    };
};

def start(){
    network.online;
    makeWeScrabble(Android.parent);
};

self;
