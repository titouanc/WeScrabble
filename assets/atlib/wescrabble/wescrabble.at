import ~.suggestion;
import ~.letterset;
import ~.tamtam;

/* Direct P2P communication type */
deftype AnAwesomeWeScrabble;

/* The whole alphabet */
def alphabet := "abcdefghijklmnopqrstubwxyz".explode();

def makeWeScrabble(UI){
    def log := Logger("WeScrabble");

    UI.setAppTitle("We Scrabble /o<");

    object: {
        def mySelf := self;
        def table := (1***15).map: {|_| (1***15).map: {|__| Suggestion.EMPTY}};
        def observers := jlobby.java.util.LinkedList.new();
        def letters := LetterSet.new([]);

        deftype TeamA;
        deftype TeamB;
        def opponnentOf: team {if: team == TeamB then: {TeamA} else: {TeamB}};
        def indexOfTeam: team {if: team == TeamA then: {0} else: {1}};

        deftype Player;
        deftype Letter;
        deftype Word;

        def myTeam := nil;
        def myName := UI.getMyName();

        def notifyObservers(){
            def it := observers.iterator();
            while: {it.hasNext()}
            do: {
                it.next().update();
            };
        };

        /* Initialize tuplespace */
        def Ts := TamTam();

        // Apply incoming suggestions
        Ts.observe: (tuple: [Word, var: `_, var: `sugg]) do: {|tup|
            def sugg := tup.fields[3];
            sugg.applyOn(table);
            UI.showMessage(sugg.repr());
            notifyObservers();
        };
        /**/

        def hasNoTeam(){myTeam == nil};
        def assignTo: team {
            myTeam := team;
            UI.setTeam(indexOfTeam: myTeam);
            Ts.accepts: {|tup|
                /* Only accept letters from my team */
                (tup.fields[1] != Letter).or: {tup.fields[2] == myTeam}
            };
            Ts.put(tuple: [Player, myTeam, myName]);
            injectLetters();
            pickLetters(7);
        };

        /* Pick letters from the bag */
        def pickLetters(n){
            if: n <= 0
            then: {
                def list := letters.toList();
                UI.showMyLetters(list);
            }
            else: {
                Ts.take: (tuple: [Letter, myTeam, var: `l]) do: {|tup|
                    letters.add(tup.fields[3]);
                    pickLetters(n - 1);
                };
            };
        };

        /* Add letters in the bag */
        def injectLetters(){
            spawn: {
                randomLetters(20).each: {|l|
                    Ts.put(tuple: [Letter, myTeam, l]);
                };
            };
        };

        /* The local user plays a suggestion */
        def play(sugg){
            {|return|
                if: hasNoTeam
                then: {
                    UI.showMessage("You are not in any team !");
                    return(false);
                };

                def newLetters := letters - LetterSet.new(sugg.requiredLetters(table));
                if: newLetters.positive.not
                then: {
                    UI.showMessage("You don't have all required letters (" + letters.toList.toString + ")");
                    return(false);
                };

                if: sugg.validOn(table, {|err| UI.showMessage(err)})
                then: {
                    Ts.put(tuple: [Word, myTeam, sugg]);
                    letters := newLetters;
                    UI.showMyLetters(letters.toList());
                    pickLetters(7 - letters.size());
                    return(true);
                };
                
                false;
            }.escape()
        };

        def remoteInterface := object: {
            def getName(){myName};

            /* Someone joined the game and requests a team */
            def getTeamAssignation(otherName){
                if: mySelf.hasNoTeam
                /* None of us is assigned: assign teams based on name order */
                then: {
                    def t := if: (myName <=> otherName) > 0
                             then: {mySelf.TeamA;}
                             else: {mySelf.TeamB};
                    mySelf.assignTo: t;
                    opponnentOf: t;
                }
                /* I'm assigned, return the less populated team */
                else: {
                    def PlayerTuple := tuple: [Player, var: `team, var: `name];
                    def players := mySelf.Ts.getAll(PlayerTuple);
                    /* Count nb of players in TeamA - nb of player in TeamB */
                    def nA := players.inject: 0 into: {|res,tup|
                        res + (if: tup.fields[2] == mySelf.TeamA
                               then: {1}
                               else: {-1});
                    };
                    if: nA < 0
                    then: {mySelf.TeamA}
                    else: {mySelf.TeamB}
                }
            };
        };

        def localInterface := object: {
            def getLetterAt(row, column){
                mySelf.table[row+1][column+1]
            };

            def addWord(word, row, col, horizontally){
                mySelf.play(
                    Suggestion.new(
                        mySelf.myName, word, row+1, col+1, horizontally
                    )
                );
            };

            def addObserver := mySelf.observers.&add;

            def getMyLetters(){
                mySelf.letters.toList();
            };
            
            UI.setBackend(self);
        };

        export: remoteInterface as: AnAwesomeWeScrabble;
        when: AnAwesomeWeScrabble discovered: {|other|
            when: other<-getName()@TwoWay becomes: {|name|
                UI.showMessage("Discovered new player " + name);
                when: other<-getTeamAssignation(myName)@TwoWay becomes: {|team|
                    if: mySelf.hasNoTeam
                    then: {mySelf.assignTo: team;}
                };
            };
        };
    };
};

def start(){
    network.online;
    makeWeScrabble(Android.parent);
};

self;
