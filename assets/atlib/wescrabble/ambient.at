def Peer := isolate: { 
    import /.at.lang.futures;

    def ref;
    def online;
    def backlog;

    def init(ref, online := true){
        self.ref := ref;
        self.online := online;
        self.backlog := [];

        when: ref disconnected: {online = false};
        when: ref reconnected: {
            online = true;
            send_backlog();
        };
    };

    def send_backlog(){
        backlog.each: {|msg| ref <+ msg};
        backlog := [];
    };

    def send(msg){
        if: online
        then: {ref <+ msg;}
        else: {
            backlog := backlog + [msg];
        }
    };
};

def AmbientRefMirror := mirror: {
    def peers;
    def offline;
    def backlog := [];

    def init(base, T){
        super^init(base);
        peers := [];

        whenever: T discovered: {|remote|
            def p := Peer.new(remote);
            peers := peers + [p];
            backlog.each: {|msg| p.send(msg)};
        };
    };

    def receive(msg){
        backlog := backlog + [msg];
        peers.each: {|p| p.send(msg)};
    };
};

deftype AmbientRef;

def ambient: obj as: Type {
    object: {} taggedAs: [AmbientRef] mirroredBy: {|base|
        export: obj as: Type;
        AmbientRefMirror.new(base, Type);
    };
};

self;
